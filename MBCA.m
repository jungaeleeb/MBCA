function [newY,delta_,Qstat,pval] = MBCA(Y,F,batchlabel,targetbatch,depth)
%Multi Batch Covariance Adjustment
%   [newY,delta_,Qstat,pval] = MBCA(Y,F,batchlabel,depth) performs a batch
%   adjustment such that covariances among batches are equalized.
%
%   For example, [newY] = MBCA(Y,F,batchlabel) generates an adjusted data
%   set 'newY' substuting a input data set 'Y'.
%
%   Input: 1) 'Y' is (p by n) whole data matrix with K batches (p > ni); 
%           e.g., Y = [Y1 Y2] where Y1,Y2 are (p by n1),(p y n2) matrix.
%
%          2) 'F' is (q by n) factor matrix (q < ni) ; q is the number of
%          factors reduced from p dimension.
%          Note : If 'F' is empty (F=[]), the MBCA will conduct 'k-means cluster'
%          to generate q by n matrix. 
%             
%          3) 'batchlabel' is a vector of group labels (ex. 111222333).

%          4) 'targetbatch' is a batch that all batches adjust toward.
%             [a] (default) 'targetbatch = 0' means pooled covariance:((n1-1)S1+...+(n_k-1)S_K)/(n-K)
%             [b] targetbatch should be integer(e.g., 1,2,3...), which
%             implies that data sets are adjusted toward S1,S2,S3,...etc.

%          5) 'depth' is a searching depth of sparse level in covariance
%          estimates.
%             [a](default) 'depth = 2' extends the searching range by two steps from a common delta.
%             [b] depth should be integer (e.g., 1,2,3,4... but do not recommend too high number due
%             to computational efficiency)
%         
%              
%         
%   Output: 1) 'newY' is a (p by n) adjusted data matrix substituting Y
%
%           2) 'delta_' is a (K by 1) vector of sparse level for each
%           batch.
%
%           3) 'Qstat' is a test statistic for the equality of HD
%           covariance matricess [2] after batch adjustment; Smaller value
%           indicates better homogeneity among covariance matrices.                
%
%           4) 'pval' is p-value of the Qstat for the null hypothesis of
%           equal variance covariance for Gaussian Data.
%        
%   Required m-file function: covtestQsvd.m
%
%   References:
%
%   [1] Fan et al. (2008), High dimensional covariance matrix estimation
%   using a factor model, Journal of Econometrics.
%   [2] Srivastava and Yanagihara (2010), Testing the equality of several
%   covariance matrices with fewer observations than the dimension, Journal
%   of Multivariate Analysis.

%   Copyright 2012- JungAe Lee.

%--Start program ----------------------------------------------------%
%% Check the input argument

% The sample size and dimension
[p n] = size(Y);
n_=length(batchlabel);
if ( n ~= n_);
	error(strcat('Sample sizes do not match'));
else
    disp('------------------------------------------')
    disp(blanks(1)')
    disp(['Sample size is ' num2str(n)])
    disp(['Dimension is ' num2str(p)])
end;
clear n_;

% Check for NaNs
if any(isnan(Y(:,:)))
	error('Missing values in input data');
end

% Rearrange batchlabel
K = length(unique(batchlabel));
Kname = unique(batchlabel);
xbatchlabel=batchlabel;
for j=1:K
    batchlabel(xbatchlabel == Kname(j)) = j;
end
disp(['Number of batches is ' num2str(K)])

% targetbatch default
if nargin <= 3 || isempty(targetbatch)
   	targetbatch = 0;
else
  disp(['Target batch is batch' num2str(targetbatch)])  
end;

% depth default
if nargin <= 4 || isempty(depth)
   	depth = 2;
end;

% covariance test with before-data
X=Y'; % n by p
[Qstat0 pval0] = covtestQsvd(X,batchlabel);
disp(['Q-stat= ' num2str(Qstat0) ', p-value= ' num2str(pval0)])


%% When F matrix is empty: generate F matrix using k-means clustering
   if isempty(F) 
    
       % mean centered data: Ymc
       Ymc = Y;
       for j=1:K
           ni = sum(batchlabel==j);
           meanvec = mean(Y(:,batchlabel==j),2);
           Ymc(:,batchlabel==j) = Y(:,batchlabel==j) - repmat(meanvec,1,ni); 
       end
     
       % Number of factors: q
       q = min(21, max(floor(p/100),1)); % such that not exceeding 21 cluster
       [~, qbyn] = kmeans(Ymc,q); % pbyn is reduced to qbyn, centroid of q clusters 
       F = qbyn;  
    
       disp(['Factors are generated by k-means cluster (k=' num2str(q) ').'])
   end % end of isempty(F)
   
   
   
%% STEP1: Estimating covariance matrix based on Factor model
    clear S*
    Sp =zeros(p,p);
    Sp_=zeros(p,p);
    S=0;
    for j=1:K
        Fi = F(:,batchlabel==j);
        Yi = Y(:,batchlabel==j);
        B = Yi*Fi'*(inv(Fi*Fi')); % p by q coefficient matrix
        covF = cov(Fi');          % q by q sample covariance of F
        E = Yi-B*Fi;              % residual matrix
        ni = sum(batchlabel==j);  
        Sigma0 = diag(diag((1/ni).*(E*E')));
        Sigmah = B*covF*B'+ Sigma0;
        varname = genvarname('S',who);     
        eval([varname ' = j;'])  ;
        eval([varname 'fac = Sigmah;']) ;
        Sp = Sp + ((ni-1)/(n-K))*Sigmah;
        if targetbatch==j
            Sp_ = Sigmah;
        end
    end
    if targetbatch ~= 0
        clear Sp
        Sp = Sp_;
    end
    clear Sigmah
    % expect to get S1fac, S2fac, S3fac and S4fac;
    
    %Sp = (78*S1fac + 177*S2fac + 103*S4fac)/358;
    
disp('------------------------------------------')
disp('Factor covariance matrices are calculated.')

%% STEP2: batch adjust : mean-centering + covariance
disp('Batch adjusting...')
adjdata = zeros(p,n);
%Sp_sqrt = sqrtm(Sp);
% ***** use svd for the efficient computation
[U D V] = svd(Sp);             
diagD = diag(sqrt(diag(D)));
Sp_sqrt = U*diagD*V';

clear A*; 
A=0;
for j=1:K  
        ni = sum(batchlabel==j); 
        meanvec = mean(Y(:,batchlabel==j),2);
        % ***** use svd for the efficient computation
        eval(['[U D V] = svd(S' int2str(j) 'fac);'])  % S1fac = U*D*V';
        diagD = diag(1./sqrt(diag(D)));
        Si_invsq = U*diagD*V';
        Ai = Sp_sqrt*Si_invsq;
        varname = genvarname('A',who);     
        eval([varname '=Ai;']);            % save to A1, A2, etc.
   adjdata(:,batchlabel==j) = Ai*(Y(:,batchlabel==j) - repmat(meanvec,1,ni));
disp(['Batch' num2str(j) ' is adjusted.']) 
end;
muvec = mean(Y,2);
adjdata = adjdata + repmat(muvec,1,n);  % mean adjusting
clear Ai
%expect to get A1,A2...and initial adjdata

%% STEP3: Optimizing sparse level
disp('Optimizing sparse level...')

% range of delta
maxK = zeros(1,K);
for j=1:K
    eval(['Ai = A' int2str(j) ';']); 
    offAi = Ai + eye(p)*100;
    offdiagvec = reshape(offAi,p^2,1);
    offdiagvec(offdiagvec > 50)=[];
    maxK(j) = max(offdiagvec);
end
maxdelta = floor(max(maxK)*10)*0.1;
maxdelta = min(maxdelta,0.3);

disp(['Search from 0 to ' num2str(maxdelta) ' for delta'])

deltavecc = [0:0.01:maxdelta]'; % sparse level
Qpval_delta = zeros(length(deltavecc),2);
for deltai=1:length(deltavecc);
       %---- adjust with delta=0.01...
        newY=adjdata;
        delta=deltavecc(deltai);
        for j=1:K    
            eval(['Ai=A' int2str(j) ';'])
            sparseAi = Sparsemat(Ai,delta);
            ni = sum(batchlabel==j);    
            meanvec = mean(Y(:,batchlabel==j),2);
        newY(:,batchlabel==j) = sparseAi*(Y(:,batchlabel==j) - repmat(meanvec,1,ni)) ...
                                + repmat(muvec,1,ni);
        end; 
        
        %--caculate Q-stat for the input delta
        [Q pval] = covtestQsvd(newY',batchlabel);
        Qpval_delta(deltai,:) = [Q pval];
             
% disp(['complete with delta = ' num2str(delta)])         
end 
[~, idx] = min(Qpval_delta(:,1)); 
delta_c = deltavecc(idx);

disp(['=> Optimal common delta is ' num2str(delta_c)])

%% STEP4: Optimizing sparse level by batch
disp('Optimizing sparse level by batch...')

% extend the searching range from the common delta
deltavec0 = delta_c;
for idepth = 1:depth
    extendleft = delta_c - 0.01*idepth;
    extendright = delta_c + 0.01*idepth;
    if extendleft < 0
        deltavec0 = [deltavec0;extendright];
    else
        deltavec0 = [extendleft;deltavec0;extendright];
    end
end

% all possible combinations of delta for K batches
D = length(deltavec0);
deltamat = deltavec0;
for j=1:K-1
    x = repmat(deltamat,D,1);
    y = sort(x(:,1));
    deltamat = [y x];    
end
Niteration = size(deltamat,1);

Qpval_deltamat = zeros(Niteration,2);
for id = 1:Niteration;
    deltavec = deltamat(id,:);
    
        %---- adjust with delta=0.01...
        newY=adjdata;
        for j=1:K    
            eval(['Ai=A' int2str(j) ';'])
            sparseAi = Sparsemat(Ai,deltavec(j));
            ni = sum(batchlabel==j);    
            meanvec = mean(Y(:,batchlabel==j),2);
        newY(:,batchlabel==j) = sparseAi*(Y(:,batchlabel==j) - repmat(meanvec,1,ni)) ...
                                + repmat(muvec,1,ni);
        end; 
        
            [Q pval] = covtestQsvd(newY',batchlabel);
            Qpval_deltamat(id,:) = [Q pval];            
            
end % end of for deltai=1:length(deltavec);

[~, idx] = min(Qpval_deltamat(:,1));
delta_ = deltamat(idx,:);

disp(['=> Optimal delta for each batch is ' num2str(delta_)])
%% STEP5: Re-adjusting with optimal delta

for j=1:K
    eval(['Ai=A' int2str(j) ';'])
    sparseAi = Sparsemat(Ai,delta_(j));
    ni = sum(batchlabel==j); 
    meanvec = mean(Y(:,batchlabel==j),2);
newY(:,batchlabel==j) = sparseAi*(Y(:,batchlabel==j) - repmat(meanvec,1,ni));
end;
newY = newY + repmat(muvec,1,n);

%% Report the result
if targetbatch == 0
    [Qstat pval] = covtestQsvd(newY',batchlabel);
    disp('All batches are optimally adjusted!')
    disp('------------------------------------------')
    disp('Test result for the equal covariances:')
    disp(['=> Q-stat=' num2str(Qstat) ', p-value=' num2str(pval)])
else
    targetB = Y(:,batchlabel==targetbatch);
    nj = size(targetB,2);
    
    otherB = newY(:,batchlabel~=targetbatch);
    nk = size(otherB,2);
    labeljk = [ones(1,nj) 2*ones(1,nk)];
    [Qstat pval] = covtestQsvd([targetB otherB]',labeljk);
disp('All batches are optimally adjusted!')
disp('------------------------------------------')
disp('Equal covariances test: target batch vs. the others')  
disp(['=> Q-stat=' num2str(Qstat) ', p-value=' num2str(pval)])
end %enf of targetbatch == 0
end %end of the function


function [B] = Sparsemat(A,delta)
% This function sparses (p by p) matrix A. Off-diagonal elements of A 
% under delta are forced to be zero. 
%
% input: 'A' is (p by p) square matrix.
%        'delta' is sparse level(ex. usually 0.01 ~ 0.1).
%
% output: 'B' is the sparsed A.
%
%-----------------------------------------------------------------------%
p = size(A,1);
B=A;
for r = 1:p
    for c = r+1:p
        if abs(A(r,c)) < delta ;
               B(r,c) = 0;
        end;
        if abs(A(c,r)) < delta ;
               B(c,r) = 0;
        end;        
    end
end
end
